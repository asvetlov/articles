Title: Числа в Python 3
Labels: python, int, float, decimal, fraction, python3

Что приходит в голову при словах «числа в Питоне?»

`int` и `float`. Если речь идет о *Python 2* — еще и упразднённый `long`.
Наверное, вспомнится очень мало где используемый `complex`.

Я же хочу рассказать о `Decimal` и `Fraction`.

Decimal
-------

Просто незаменим, если нужно считать деньги. Представим, что нам нужно
работать с *гривной* (это такая украинская валюта, с точки зрения
рассматриваемого вопроса ничем не отличающаяся от рубля, евро или
доллара). Сотая часть гривны называется *копейкой*. Естественно
думать, что гривны будут представлены целой частью числа, а копейки —
дробной.

Что произойдёт, если для денег мы станем использовать `float`?

Как я писал в
[статье](http://asvetlov.blogspot.com/2011/02/blog-post.html): *4 грн
31 коп* будут на самом деле иметь внутреннюю запись
*4.3099999999999996*.  Да, при печати всё показывается нормально если
у вас *Python 2.7+* — но внутри это всё же чуть-чуть иное число!

И если работать с такими числами (складывать, вычитать, делить и
умножать) — ошибка будет нарастать и рано или поздно превысит копейку,
а потом счет пойдет и на гривны. Чем больше операций — тем выше ошибка.

В результате дебет перестаёт сходиться с кредитом, бухгалтерия встаёт
на уши и разработчик получает большую проблему на свою голову (случай
из жизни моего друга).

Чтобы этого избежать, нужно использовать
[decimal](http://docs.python.org/library/decimal.html) — который
никогда ничего не теряет.

Внутри *decimal* представлен как *знак*, *набор цифр* и *положение
десятичной точки* — т.е. нет никакого округления.

Использование очень простое:

    >>> from decimal import Decimal
    >>> Decimal("4.31")
    Decimal('4.31')
    >>> Decimal("4.31") + Decimal("1.10")
    Decimal('5.41')

Все стандартные операции над *decimal* работают так же хорошо, как и с
*просто* числами.

*К слову, базы данных как правило имеют встроенную поддержку этого
типа, а драйвера [DBAPI](http://www.python.org/dev/peps/pep-0249/) и
ORM вроде [Django](https://docs.djangoproject.com/) и
[SQLAlchemy](http://www.sqlalchemy.org/) тоже умеют работать с
*decimal*.*

К сожалению, этого базиса недостаточно, а
[документация](http://docs.python.org/library/decimal.html),
исчерпывающе полная, — не содержит простых ясных инструкций для
ленивого программиста.

Пример:

    >>> Decimal("1.10") / 3
    Decimal('0.3666666666666666666666666667')

Ой! Зачем так много цифр, ведь у нас гривна с копейками?!!

Дело в том, что помимо `Decimal` есть еще и `Context`. По умолчанию у
него точность в 28 чисел в дробной части, что явно многовато для
валюты. Настроим на 2 знака:

    >>> from decimal import getcontext
    >>> getcontext().prec = 2
    >>> Decimal('1.10') / 3
    Decimal('0.37')

Уже лучше.

Правила округления тоже задаются *контекстом*. По умолчанию это
`ROUND_HALF_UP` — округлять вверх, если цифра пять и больше. Как в
школе учили. Можно настроить и другой способ — читайте
[документацию](http://docs.python.org/library/decimal.html). Еще можно
указать, чтобы при разных ситуациях (потеря точности или бесконечность
в результате, например) генерировалось исключение а не происходило
округление. Кому надо — пусть изучает эту самую *документацию*,
ключевое слово **trap**.

Вернемся к наиболее распространенным задачам.

Что делать, если часть вычислений нужно проводить с точностью «до
копеек», а некоторые (например, то же сведение баланса и подсчет
налогов) — до сотых долей копеек?

Наиболее практичный способ — создание своего *контекста* и применение
его в *with statement*:

    >>> from decimal import Context, localcontext
    >>> with localcontext(Context(4)):
    ...     print(repr(Decimal("1.10") / 3))
    Decimal('0.3667')

Округление:

    >>> Decimal('1.12').quantize(Decimal('0.1'))
    Decimal('1.1')
    >>> Decimal('1.16').quantize(Decimal('0.1'))
    Decimal('1.2')

**Внимание! Округлять можно только до той максимальной точности,
 которая позволена текущим контекстом.** Сейчас у нас *глобальный
 контекст* имеет точность 2.

    >>> getcontext().prec = 2
    >>> Decimal('1.10').quantize(Decimal('0.000001'))
    Traceback (most recent call last):
    ...
    decimal.InvalidOperation: quantize result has too many digits for current context

Вот и всё.

За рамками статьи осталось многое.  Моя цель — дать
необходимый минимум знаний, требуемый для работы с денежными
единицами. Остальное, повторюсь ещё раз, найдете в
[документации](http://docs.python.org/library/decimal.html) — она
большая и исчерпывающая, содержит описание многих дюжин доступных
функций.

И, тем не менее, изложенного достаточно для практически
любой повседневной работы.

**Важное дополнение. Изначально *decimal* был написан на *чистом
 питоне*. Т.е. корректно считал, но делал это *довольно медленно*. Не
 настолько плохо, чтобы отказываться от него (тем более что
 альтернатив нет) — но часто скорость важна и хотелось бы побыстрее.**

**В *Python 3.3* вошёл ускоритель (подключается автоматически). Автор
 — Stefan Krah. Большое спасибо этому человеку. Благодаря его труду
 производительность *decimal* повысилась настолько, что скорость
 вычислений стала сопоставима с `int` и `float`. **

**Всем читающим —
 намёк: переходите на *Python 3.3* **


Fraction
--------

Предназначен для работы с [обыкновенными
дробями](http://ru.wikipedia.org/wiki/%D0%94%D1%80%D0%BE%D0%B1%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)#.D0.9E.D0.B1.D1.8B.D0.BA.D0.BD.D0.BE.D0.B2.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B4.D1.80.D0.BE.D0.B1.D0.B8)

В школе все учили дроби: «одна треть плюс одна треть равно две трети».

Не все обыкновенные дроби имеют точное конечное представление,
укладывающееся в границы `float`.

Пример:

    >>> 7/71*71 == 7
    False

А теперь с *fraction*:

    >>> from fractions import Fraction
    >>> Fraction(7, 71) * 71 == 7
    True

Практическое применение:

С конца мая 2011 я работаю в проекте [Апокалипсис](http://2056.ru/).
Это онлайновая игра с пошаговой боёвкой. Каждый игрок имеет
определённое количество очков на ход. Передвижение на одну клетку —
одно очко. Выстрел — скажем, три очка. Ходят все одновременно.

У меня 7 очков движения, у противника 8. Значит, я совершаю свои
действия со скоростью 1/7, а противник — 1/8.

Я сдвинулся на одну клетку и выстрелил.

И тут очень важно правильно посчитать, когда произошел выстрел: чуть
раньше супостата, чуть позже или точно одновременно.  Буквально каждое
мгновение — вопрос жизни или смерти в игровом бою.

`float` верить нельзя: если событие должно наступить *одновременно* —
ошибка округления наверняка *соврёт* в ту или другую сторону. А
пользователи игры забросают нас, разработчиков, виртуальными гнилыми
помидорами.

`Fraction` считает честно, что к тому же значительно облегчает игровую
математику: 1/3 всегда равна «одной трети».

Заключение
----------

Если читатель знал о существовании Fraction и Decimal, использовал их
на полную катушку — честь и хвала, я ничего нового не сказал.

Если же, столкнувшись с областью применения этих числовых типов,
читатель вспомнит мои рецепты правильного их приготовления — статья
свою работу выполнила.

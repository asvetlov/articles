=================================
Питон: импорт и модули - часть 4
=================================

Мы подробно рассмотрели структру *модулей* и *пакетов*, относящиеся к делу
атрибуты из модуля `sys`, хранящие информацию о загруженных модулях и том,
где искать новые.

Давайте теперь более внимательно остановимся на собственно *искателях* и
(загрузчиках* из
[PEP 302 - New Import Hooks](http://www.python.org/dev/peps/pep-0302/).

*Искатель*
==========

    class Finder:
        def find_module(self, fullname:str, path:[str]=None) -> Loader:
            pass

Про него уже практически все сказано в предыдущей части. Должен вернуть
объект загрузчика, если может обработать запрашиваемое в `fullname`
полное имя модуля — или вернуть `None`.

Замечу лишь, что часто *искатель* и *загрузчик* реализуют в одном классе
(например, стандартный `zipimporter`).

Для таких классов `.find_module`, естественно,  должен вернуть `self`.

*Загрузчик*
===========

С *загрузчиком* ситуация несколько сложнее. Помимо обязательного `.load_module`
могут быть реализованы еще несколько методов:

* `get_data`
* `get_code`
* `is_package`
* `get_source`

::
    class Loader:
        def load_module(self, fullname:str) -> types.ModuleType:
            pass

        def get_data(self, path:str) -> bytes:
            pass

        def get_code(self, fullname:str) -> types.TypeCode:
            pass

        def is_package(self, fullname:str) -> bool:
            pass

        def get_source(self, fullname:str) -> str:
            pass

Эти необязательные методы логически разбиваются на две части: работа с данными
и расширенная поддержка

Основной интерфейс
------------------


Настала пора объяснить, что должен сделать *загрузчик* для импорта модуля::

    def load_module(self, fullname:str) -> types.ModuleType:
        pass

`fullname` — строка с *полным именем модуля* (`a.b.c`).
Метод возвращает загруженный модуль.

Например, делая это так (для `zip` архива)::

    def load_module(self, fullname:str) -> types.ModuleType:
        # self.zippath - путь к архиву
        zip = zipfile.ZipFile(self.zippath)
        try:
            path = '/'.join(fullname.split('.')) + '.py'
            is_package = False
            # проверим, есть ли такой модуль?
            info = zip.infoname(path)
        except KeyError:
            # Может, это пакет?
            is_package = True
            package = '/'.join(fullname.split('.'))
            path = package + '/__init__.py'
            try:
                info = zip.infoname(path)
            except KeyError:
                # Если и здесь не повезло - запрашиваемого модуля в архиве нет
                # Выбросим ImportError с приличной информацией.
                # Этого можно и не делать - любое необработанное
                # исключение из load_module приведет к ImportError
                raise ImportError('There are no module %s' % fullname)

        source = zip.open(path)
        filename = self.zippath + '/' + path, 'exec'
        code = compile(source, filename)

        mod = sys.modules.setdefault(fullname, imp.new(fullname))
        mod.__file__ = filename
        mod.__loader__ = self
        if is_package:
            mod.__path__ = [self.zippath + '/' + package]
        exec code in mod.__dict__
        return mod


Код не оптимален и не работает с `.pyc` файлами — для демонстратора это
не важно. zipimporter написан на C — любопытные могут почитать исходники
[Modules/zipimport.c](http://svn.python.org/view/python/branches/py3k/Modules/zipimport.c?view=markup).

Итак, что требуется:

* создать модуль и зарегистрировать его в `sys.modules`.
    Если он там уже был — используется готовый.
    Этот случай  возможен при вызове `reload(a.b.c)`.
    Обратите внимание: модуль регистрируется *перед* его выполнением в `exec` —
    чтобы разорвать возможную рекурсию, если код модуля явно или неявно
    (через импорт других модулей, которые в свою очередь...)
    импортирует себя самого.
* установить переменные `__file__` и `__loader__` - это обязательно
* если была просьба загрузить пакет — то также нужно установить `__path__`.
* наконец, нужно выполнить *код модуля* в *пространстве имен* этого самого модуля
* вернуть получившийся модуль.
* все не обработанные исключения приведут к ImportError.


Здесь нужно сделать важное примечание.

Меня неоднократно спрашивали, когда наконец
починят Питоновский импорт, сделав его по настоящему рекурсивным,
как в Java или C#.

Ответ — никогда. Java и C# *расширяют* пространство имен файла,
*добавляя в него новые имена*.

Питон *исполняет* код модуля. В процессе этого создаются функции, классы
и переменные — верно. Но созданием новых имен дело не ограничивается — в
коде модуля можно писать любые инструкции (statements) на верхнем уровне.

В этом кардинальное различие. Если будут просьбы — могу подробно разъяснить
"что к чему", но не в этой статье.

Данные
------

    def get_data(self, path:str) -> bytes:
        pass

Позволяет загрузить файл данных, лежащий где-нибудь рядом с модулем.
`path` - путь к файлу. Метод возвращает `bytes` (`str` для Python 2) -
содержимое файла, прочитанное в _бинарном_ режиме. Для пути в файловой системе
эквивалентно `open(path, 'rb').read()`. Если файл не найден - следует выбросить
исключение IOError.

Позвольте мне сказать несколько слов о том, зачем этот метод нужен.

Рассмотрим следующий _пакет_:

* `package`
    * `__init__.py`
    * `a.py`
    * `data.dat`

Как видим, в нем помимо `.py` файлов есть еще и `data.dat` - какой-то файл,
требующийся для работы пакета.
Это может быть картинка, текстовая конфигурация или что-то еще.

Пакет может лежать где угодно, поэтому нужно уметь читать файл по _относительному_
пути. Если все находится в файловой системе, можно написать в `package.a`
что-то вроде

    import os

    def get_data():
        folder = os.path.dirname(__file__)
        path = os.path.join(folder, 'data.dat')
        with open(path, 'rb') as f:
            return f.read()

Этот код будет работать, но как быть с `zip` архивами?

Дело в том, что `__file__` для модуля `a` из архива `lib-1.3.zip`
будет содержать что-то вроде `...lib-1.3.zip/package/a.py`.

Чтобы прочитать `data.dat` придется воспользоваться `zipfile` (при этом еще и
довольно нетривиально парсить `__file__`, отделяя имя архива от пути внутри него).

А если это вообще не `zip` архив, а что-то с зарегистрированным *искателем* и
*загрузчиком*?

Вспоминаем, что *расширение импорта* обязано зарегистрировать *загрузчик*
в `.__loader__`
(а стандартный метод загрузки этот атрибут не устанавливает —
нет единой системы, как ни жаль).
Можно написать так::

    import os, sys

    def get_data():
        folder = os.path.dirname(__file__)
        path = os.path.join(folder, 'data.dat')
        loader = sys.modules[__name__].get('__loader__')
        if loader is not None:
            # Грузимся через расширение
            return loader.get_data(path)
        else:
            # Используем стандартный путь
            with open(path, 'rb') as f:
                return f.read()

Все еще не очень хорошо — нужно помнить о двух способах сделать
одно и то же дело. К счастью, есть `setuptools` и `distribute`
(рекомендую последний, но в данном случае разница невелика).

Просто пишем::

    import os, pkg_resources

    def get_data():
        return pkg_resources.resource_string(__name__, 'data.dat')


Перечислю все функции из pkg_resources, относящиеся к загрузке данных
([читайте здесь](http://peak.telecommunity.com/DevCenter/PkgResources#resourcemanager-api)).

* resource_exists(package_or_requirement, resource_name)
* resource_stream(package_or_requirement, resource_name)
* resource_string(package_or_requirement, resource_name)
* resource_isdir(package_or_requirement, resource_name)
* resource_listdir(package_or_requirement, resource_name)

Детальное рассмотрение великой (делает много полезных вещей)
и ужасной (очень тяжело читать исходный код)
библиотеки `setuptools` выходит за рамки этой статьи.

Остался маленький, но неприятный вопрос.

`__file__` — это строка. Точка. Что там будет — решает создатель *загрузчика*.
Но при этом PEP 302 говорит, что для get_data можно использовать функции `os.path`.
Которые для linux используют `/` как разделитель, а для Windows предпочитают
'\\' (но и простой '/' тоже подойдет). Загрузчику приходится как-то обрабатывать
оба варианта (например, делать path.replace('\\', '/')) - помните об этом.

Код
----

::

    def get_code(self, fullname:str) -> types.TypeCode:
        pass

    def is_package(self, fullname:str) -> bool:
        pass

    def get_source(self, fullname:str) -> str:
        pass

С оставшейся частью спецификации все просто:

* `is_package` скажет, это пакет или просто модуль
* `get_code` вернет `code object` для модуля (который нужно выполнить)
* `get_source` покажет исходный питоновский код

Непонятно лишь, зачем это все нужно?

Ответ: "простому программисту" эта часть не нужна вовсе.
Но разработчику *расширения импорта* все же полезно реализовать последние
три метода спецификации.

Полученную информацию используют:

* анализаторы кода
(например, превосходный [coverage](http://pypi.python.org/pypi/coverage))
* упаковщики (py2exe, pyfreeze и прочие).
* наконец, правильный отладчик сумеет вызвать `get_source` даже для вашего
модуля, загруженного из базы данных! На практике это означает, что можно
видеть исходники, указывать в них точки остановки (breakpoints) и работать
с этим упакованным кодом весьма комфортно.

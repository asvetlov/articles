Пишем import hook.
==================


В тернете уже очень много русскоязычной информации о Питоне.  И если о
пользовательском интерфейсе или Джанге пишут давно, то с недавних пор
я вижу много постов о внутренностях Питона, всяких дескрипторах,
декораторах и прочем метапрограммировании. Добавлять еще одну статью о
том, как сделать свой дескриптор - пошло.

К счастью, существует много плохо описанных возможностей, остановимся
на одной из них.

Немного теории
--------------

Import hook - механизм для пользовательского расширения стандартной
машинерии подключения модулей.  В стандартной поставке он уже давно
используется - так работает импорт из zip архивов.  Конечно, одними
архивами возможности не ограничиваются.  Основной документ - 
[PEP 302](http://python.org/dev/peps/pep-0302/ PEP 302),
который подробно описывает, как все делать.  К сожалению, недостаточно
подробно и не совсем полно.  В Python 3.1 ситуация значительно
улучшилась с введением importlib, к тому же есть проект
[importers](http://code.google.com/p/importers/ importers) - но
давайте будем реалистами.  Третий Питон пока почти никто не
использует, поэтому приведенный код должен работать на Python 2.6.

Итак, короткая выжимка из документации.

Для реализации import hook нужно создать два класса:

    class Finder(object):
        """Регистрируемая ловушка

	Ищет модуль. Регистрируется в sys.
	""" 

        def find_module(self, fullname, path=None):
	    """Определяет, может ли эта ловушка загрузить требуемый модуль.   

	    `fullname` - полное имя запрашиваемого модуля.
	    Например, spam.ham.habam
	    `path` - используется для мета-ловушек, о которых - позже.
	    Возвращает loader или `None` если запрашиваемого модуля не существует
	    """

	    
    class Loader(object):
        """Загрузчик модуля. 

	Компилирует его, если нужно, устанавливает специальные аттрибуты и т.д.
	"""

        def load_module(self, fullname):
	    """Основная часть загрузчика.

	    `fullname` - полное имя запрашиваемого модуля, 
	    аналогично `Finder.find_module`
	    Возвращает экземпляр загруженного модуля
	    """

	# Необязательная часть
	def get_data(self, path):
	    pass

	def is_package(self, fullname):
            pass

   	def get_code(self, fullname):
	    pass

	def get_source(self, fullname):
            pass


Использование
-------------

Чтобы было интересней читать, давайте рассмотрим вполне реальный пример.
Нужно сделать биллинг для провайдера.  Особенность в том, что
провайдер желает иметь возможность по разному тарифицировать трафик
(ночью, скажем, дешевле).  Более того, он хочет постоянно менять
правила - например, сделать бесплатное пользование на 8 марта и так
далее.  И хранить эти правила в базе данных.  Удобно было бы
записывать в базу именно код, а не какое-то декларативное описание -
просто потому, что так легче эти правила менять и проще их записывать.
Кроме того, это гораздо более гибкое решение.


Со стороны обрабатывающего кода все будет выглядеть так: 

    calc = for_date(date) 
    amount = calc.bill(data)

* `date`: `datetime.date` - дата, на которую нам нужен калькулятор
* `calc`: `ICalc` - объект, который все посчитает
* `data`: 24 элементный кортеж - количество килобайт, скачанных за
каждый час в тарифицируемых сутках
* `amount`: `decimal.Decimal` - сумма, которую нужно
  заплатить. Никогда не используйте `float` для подсчета денег.


Калькулятор будет строится из базы "на лету" для запрашиваемого дня.
Конечно, в настоящей системе будет важен еще и пользователь (его
тарифный план) - но пользователя опустим для простоты.  Еще одно
упрощение - вместо базы данных будем использовать файловую систему, в
которую запишем файлы-модули со специально закодированными именами.
Функция `for_date` построит пакет (имеется в виду Питоновский package),
найдет в нем объект-калькулятор, создаст его и вернет. Дальше - как
обычно.

_Модуль в классическом понимании - это .py файл, лежащий в одной из
папок, перечисленных в sys.path.  Пакет - папка, опять же доступная
через `sys.path` и содержащая `__init__.py` и, возможно, несколько
других .py файлов.  Распространение только .pyc без .py файлов, иногда
применяемое в качестве меры по сокрытию кода - крайне не рекомендуется
и, возможно, перестанет работать в новых версиях Питона.  Если хотите
защитить ваш код - делайте это правильно, через import hooks.  К тому
же такой подход гораздо надежней защитит ваши данные._

Перед использованием зарегистрируем базу данных:

    install(pkg_resource.resource_filename(__name__, 'db'))

    def install(path):
        sys.meta_path.append(Finder(path))

Ничего сложного. Добавили путь и зарегистрировали свой hook.

Чуть интересней функция `for_date`. Она должна импортировать пакет,
выбрав его по дате.  Питон работает только со строками как именами
пакетов/модулей. Поэтому прийдется сконструировать такую строчку, а
затем вызывать `__import__`. Это - единственная причина, по которой
приходится использовать самодельную функцию вместо привычного
оператора import. Для любого другого применения было бы достаточно
зарегистрировать hook - и пользоваться стандартными средствами.

_Дополнительная бесплатная выгода: модули кешируются
Питоном. Т.е. второй вызов для той же даты будет очень быстрым._

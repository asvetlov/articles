Title: Числа с плавающей запятой: ликбез
Labels: python, float

!!!!!!!!! На Хабре уже есть очень похожая статья !!!!!!!!!!

В [предыдущей статье](http://asvetlov.blogspot.com/2011/02/blog-post.html)
я подробно расписал, как происходит преобразование числа в строку. И думал,
что на этом избитая тема закрыта.

Оказывается, нет. С периодичностью раз в неделю-две на просторах интернета
опять поднимается один и то же вопрос:

    >>> 0.1 + 0.2 == 0.3
    False

Почему `False`, когда `0.1 + 0.2` равно именно `0.3`?

Сразу же делается очень сильный вывод: у Питона неправильно реализована
арифметика чисел с плавающей запятой. Попытки указать, что вообще-то
остальные языки программирования работают точно так же, что Java или C дают
аналогичный результат и считает "железо" FPU — ни к чему не приводят.

Поэтому давайте, в рамках программы по ликвидации безграмотности, повторим
тот материал, который изучается на первом курсе высших учебных заведений.

## Немного теории

Питоновский `float` на самом деле представляет число двойной точности, которому
соответствует `double` из `C`. 64 бита: один на знак, 11 для экспоненты и
52 - мантисса. Еще один - неявная первая единица мантиссы, не записываемая
в битовом представлении. Не хочу долго останавливаться на этих скучных
подробностях -
[русская](http://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
и (предпочтительно)
[английская](http://en.wikipedia.org/wiki/Double_precision_floating-point_format)
статьи в Википедии полностью описывают применяемый формат.

Посмотрим, как выглядит `0.1`:

    >>> import struct
    >>> s = struct.pack('d', 0.1)
    >>> l, = struct.unpack('Q', s)
    >>> bin(l)[2:].zfill(64)
    '0011111110111001100110011001100110011001100110011001100110011010'

Мантисса занимает 52 младших бита в этой записи:

    >>> bin(l)[2:].zfill(64)[-52:]
    '1001100110011001100110011001100110011001100110011010'

Присмотритесь внимательно: биты повторяются. Перед нами — бесконечная дробь,
обрезанная по размеру мантиссы (тем самым 52 битам).

Как `1/3` становится бесконечной дробью при записи в дезятичном виде, так
и вполне конечная дробь `0.1` превращается в бесконечную, будучи записана
по основанию 2. Нарушение монотонности в самом конце объясняется именно
конечностью мантиссы.

К слову, `0.2` и `0.3` — тоже бесконечные двоичные дроби, можете убедится
в этом сами.

Из этого следует простой вывод: в Питоне (как и в любом другом 
языке программирования) числа `0.1`, `0.2` и `0.3` *чуть-чуть не равны*
их десятичному представлению.

## Арифметика

     >>> 0.3 - 0.1 - 0.2
     -2.7755575615628914e-17

Получается, что разность не равна *строго нулю*, а представляет собой
*очень маленькое число*. Дальше всё просто: сравнивать нужно с какой-то
заранее заданной точностью.

    >>> abs(0.3 - (0.1 + 0.2)) < 1e-12
    True

Порог подбирается исходя из задачи и оценки набегающей ошибки (чем сложнее
вычисления, тем допустимая ошибка больше).

Собственно говоря, это — общеизвестная истина, про которую постоянно забывают.

## Не числа

Не все значения, представленные в `float`, являются числами.

Например, деление на ноль вызывает исключение:

    >>> 1./0
    Traceback (most recent call last):
      ...
    ZeroDivisionError: float division

А деление на очень маленькое число дает бесконечность:

    >>> 1./1e-320
    inf

Бесконечность бывает и отрицательная:

    >>> -1./1e-320
    -inf




Title: Графический интерфейс, часть первая.
       Общие проблемы создания интерфейсов
Authors: Andrew Svetlov
public_url: http://asvetlov.blogspot.com/2011/02/blog-post_05.html

Продолжение - [во второй части](http://asvetlov.blogspot.com/2011/02/blog-post_07.html).

Хотел порассуждать о разработке интерфейсов пользователя.

Сначала - исключительно применительно к Питону.

Довольно быстро сообразил, что проблемы не зависят от применяемого 
языка программирования.

Хорошо, поговорим о создании _Graphic User Interface_ (_GUI_) 
"вообще", постаравшись проиллюстрировать 
это примерами из популярных кроссплатформенных библиотек.

И тут не всё гладко: задачи, стоящие перед разработчиком _standalone application_
на _Qt_ довольно похожи на создание полноценного интерактивного интерфейса
с помощью _ajax_, _long polling_, _web sockets_ и прочих умных слов.

Просто сайтописатели в большинстве своем этих проблем еще не осознали - 
ведь интерфейс подавляющего большинства их приложений куцый и примитивный 
по сравнению с "большими братьями". 

_В web разработке более или менее успешно решаются другие серьезные проблемы:
масштабирование, высоконагруженные системы.
Но в плане сложного интерфейса - увы и ах - запросы, как правило, невелики_.

При этом принципы дизайна и стоящие вызовы, повторюсь, очень похожи.

Итак, будем говорить о графическом интерфейсе, 
не делая принципиального различия между web и standalone приложениями.

Model-View-Controller
---------------------

Первое, что приходит в голову при мысли о хорошей архитектуре _GUI_ - _MVC_.
За детальным описанием обратитесь, например, к википедии.

_Модель_ содержит данные и бизнес-логику работы с ними - всё чётко и ясно.

А вот с _видом_ и _контроллером_ ситуация гораздо хуже.

Возможно, в `Smalltalk` (от которого всё пошло) и было четкое разделение.

В нынешних системах оно утеряно. Примеры:

1. `Django`. Есть _вид_, но _контроллер_ отсутствует. За него иногда на полном 
    серьезе выдают правила _роутинга_ (`urls.py`) - что просто смешно.

2. `Pylons`. Появился _контроллер_ (при том что _роутинг_ тоже никуда не делся),
    _вид_ отсутствует. Иногда в качестве вида пытаются указывать шаблон страницы.

3. `Pyramid`, новая поделка. В попытках уйти от неоднозначности ввели новый
    термин _ресурс_, оставив _вид_. К чести создателей Пирамиды, ребята
    постарались явно описать причины отказа от _MVC_ и предложили иную схему:
    _Model-Resource-View-Renderer_. 

Может, MVC не применима к веб разработке? А на её "родном" поле всё хорошо?

Как бы не так: `Qt`, `wxWidgets`, `WinForms`, `Swing` - все эти библиотеки
используют понятие _widget_, объединяя в нём _вид_ и _контроллер_.
Для сложных виджетов _модель_ выделяется в отдельный класс, в то время как
тривиальные моделью не обладают, предпочитая держать всё вместе.

Более того. Если вы попробуете внимательно почитать те статьи, которые явно
разделяют _модель-вид-контроллер_ -- заметите занятную вещь.

Взаимодействие между этой тройкой описывается каждый раз иначе.
Может ли _вид_ изменять _модель_? А _модель_ шлет свои сообщения _виду_ или 
_контроллеру_? Ответ на вопрос зависит от автора статьи.

_MVC_ ни разу не является _шаблоном проектирования_ (_design pattern_),
где все четко расписано: какие классы входят в шаблон, за что отвечают
и каким образом взаимодействуют.

Наверное, поэтому схема _Model-View-Controller_ не вошла в знаменитую книгу 
"Design Patterns" (_GoF_) - это просто набор благих пожеланий и никак не
строгая структура.

Похоже, концепция _MVC_ чем то напоминает смысл жизни: каждый подсознательно
чувствует, что он есть. И вместе с тем все попытки описать этот смысл
вербально ни к чему хорошему не приводят.


View
----

В мире библиотек для `GUI` наблюдается интересная стандартизация.

Веб давно и прочно сидит на `HTML+CSS`.

Это позволило выделить отдельную категорию разработчиков - верстальщики.

В последние годы тенденция распространяется и на средства разработки
standalone aplication.

Проблема в следующем: программисты, как правило - плохие дизайнеры.
Слишком разный склад ума.

Посредственный программист, являющийся при этом не самым лучшим художником - 
находка для работодателя. Я не шучу.

Что получается, если типичному программисту заказывают дизайн "в розовых тонах
с симпатичными рюшечками?".

Правильно! Изделие напоминает выпуск военно-промышленного комплекса, покрашенное
в розовый цвет и снабженное криво сидящим унылым бантиком.

Не потому, что программист сделал работу "на отвяжись" - просто он иначе мыслит.
Я тоже немного понимаю в живописи - но не сумею нарисовать ваш акварельный портрет.

Или таки нарисую (если сильно прижмут) - но мне будет стыдно, а вам неловко.

Итак, естественным образом возникла идея: раз уж дизайнеры (технические художники)
присутствуют в массовых количествах и они волей-неволей освоили вёрстку веба - 
нужно дать им похожий инструмент для создания пользовательского интерфейса
традиционных программ.


Некоторые поделки я видел уже давно - они были неуклюжие, малораспространенные 
а зачастую еще и стоили очень недешево.

Появилась идея `HTML Applications`. 
Весь интерфейс в `html`, вместо удаленного сайта используется
локально запущенный сервер, и всё оформляется в едином флаконе - запусти приложение
и увидишь красивую картинку.

Всеми уважаемая фирма Microsoft некоторое время усиленно продвигала
этот подход.

Получилось не то чтобы успешно. Причина очевидна: `html` в первую очередь
ориентирован на создание сайтов. Его выразительная мощь проигрывает традиционным
библиотекам `GUI`. `HTML Applications` были красивыми внешне, но отличались
_крайне низкой usability_.

При том подход не умер: есть множество задач, в которых он более чем оправдан.

И тем не менее это - _не mainstream_.

Сейчас присутствуют и более многообещающие альтернативы.

1. В `Qt 4.7` появились `Declarative Views` и язык разметки `QML`.
2. Microsoft выпустила `Windows Presentation Framework` (`WPF`) с разметкой в `XAML`.
3. Меня попросили добавить XUL - язык разметки пользовательского интерфейса 
    для Mozilla project. Я с ним никогда не имел дела - но пусть будет.

Возможно, есть и другие достойные продукты - я не очень внимательно следил за
этим направлением.

Как мне кажется, основная цель этих поделок: 

1. Дать возможность программистам сосредоточиться 
    на функциональной стороне продукта.
2. Предоставить дизайнерам язык разметки, очень похожий на привычный им `html/css`.
    При минимальном времени на привыкание дизайнеры могут создавать
    внешний вид программы используя _родные для библиотеки виджеты_,
    обладающие _требуемой программистам функциональностью_.

Этот подход в корне отличается от использования средств графического проектирования.

Если помните, для веба тоже были (и есть до сих пор) похожие инструменты.

Например, `Adobe Dreamweaver`. 
О "замусоренности" выдаваемой вёрстки говорить не буду: кто сталкивался - понимает.

При всех достоинствах практика показала: хороший верстальщик с твердым знанием
html и css гораздо лучше изумительного художника, выдающего результат исключительно 
в `Dreamweaver`.

В очень тяжелом случае художник может попытаться объяснить дизайнеру, 
как делать "нарезку" - избавив этим программиста от непрофильной работы.

У нашего бедняги и без того задач хватает. Будет заниматься версткой - не успеет
сделать функционал.

Такой же подход должен прийти на рынок "не веба".

Для "традиционных" _GUI_ библиотек ситуация с версткой еще драматичней.

Есть средства графического проектирования интерфейса. Они - глюкавые. Это - факт.

Гораздо легче создать _Domain Specific Language_ (_DSL_) для описания узкой области
размещения красиво оформленных элементов на форме, чем сделать удобный редактор,
работающий без ошибок.

Для набора этого текста я использую `rst` формат, 
затем `markdown` перегонит его в `html`. Набор в `emacs`.
Это гораздо удобней `Microsoft Office Word` или `Open Office Writer`, даёт лучший
контроль.

Но у автоматических средств GUI есть и более существенный недостаток.

Сейчас ими могут пользоваться только программисты. Просто потому, эта автоматика
оперирует свойствами объектов, доступными только в "программерской" документации.

В то время как для веба уже давно есть отдельные доки по html и css, написанные 
для верстальщиков и не затрагивающие даже java script.

Не говорю уже про HTTP, 
незнакомый даже большинству веб-программистов нового поколения.

Заключение
----------

Погружение в предметную область вышло неожиданно длинным.

Рассуждения об изменеиях в подходе визуалиации форм для "традиционных" приложений 
заняли очень много времени.

В следующей части хочу более детально пройти по MVC, его проблемам и альтернативным
решениям.

Есть опасение, что второй статьи такого же размера всё равно не хватит.

Продолжение - [во второй части](http://asvetlov.blogspot.com/2011/02/blog-post_07.html).


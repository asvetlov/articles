Title: Игровой контент
Labels: python, gamedev

Я работаю в команде, создающей онлайновую браузерную игру http://2056.ru

В этой статье хочу рассказать об используемом нами подходе к хранению
игрового контента.

Контентом будем называть набор данных, используемых в игре.  Он
очевидным образом делится на графику (картинки и прочие бинарные
файлы) и описание игрового мира (например, список используемого
оружия-брони со всеми характеристиками).

С графикой всё ясно. Классическая статика, которая без изменений
отдаётся браузерному клиенту.

Остальной контент чуть хитрее. Оружие нужно редактировать, меняя
характеристики.  Параметры оружия требуются как серверной так и
клиентской стороне. В дальнейшем под словом «контент» я буду
подразумевать именно структурированные данные, описывающие игровой
мир.

Довольно часто контент кладут в базу данных в том или ином
виде. Мотивация понятна — раз изменяется — значит база данных. В корне
неверное решение. Мало того, что приходится писать редактор для вещей,
карт и прочего — контент оказывается оторван от кода (в то время как
создаётся параллельно и с кодом неразрывно связан), — так ещё и
теряется версионность данных.

Конечно, можно использовать версионную БД (NoSQL часто позволяют
работать с различными версиями объектов). Но ведь программисты уже
используют системы контроля версий для кода. Почему бы не хранить там
же и контент? Бесплатно получаем версии, ветки, ревизии, список
изменений и прочие привычные штуки. Контент всегда синхронизирован с
кодом просто потому, что находится в том же репозитарии.

## Yaml

Осталось выбрать формат файлов. Мы используем `yaml` — потому что он
простой, лаконичный и наглядный. Его, в отличие от JSON или, чур меня,
чур, XML можно править в любом текстовом редакторе (как, собственно, и
код). `git diff` дает вполне читаемый вывод.

Вот пример пули (файл `a9mm.yaml`):

    type: Ammo
    title:
      en: 9mm
      ru: 9мм
    shop-category: ammo
    price: 20
    energo-price: 1
    level: 1
    icon: bullets_9mm
    image: 9mm_
    weight: 3
    caliber: '9'
    pack-size: 20



## Модели

Идем дальше. Мы используем так называемые *модели* для описания типов
контента.  Вот типичная модель:

    class Ammo(Supply):
        caliber = String()
        armor_piercing = Percent(default=0.0)
        crit = Percent(default=0.0)
        power = Int(default=0)

Пуля унаследована от боеприпаса, в дополнение к базовым параметрам
содержит калибр, бронебойность, шанс критического урона и мощность
удара. Детали не очень важны. Параметры имеют тип (целое, процент,
строка, путь к файлу и т.д.), могут быть комплексными и т.д.

## Контент-менеджер

Для работы с моделями используется контент-менеджер. Он читает `yaml`
файлы, создает экземпляры моделей и запоминает получившиеся объекты в
своих структурах (как правило — в словарях `dict`). Дальше можно
получить пулю по ее имени-идентификатору (обычно это имя `yaml` файла
без расширения) и работать: продавать, покупать, заряжать и стрелять.

Это только часть работы.

Контент нужно ещё и проверять. Например, убедится что мощность
положительная, шанс критического удара не превышает 25% и есть оружие
под калибр пули.  

Контент-менеджер может делать эти проверки. Для этого каждая модель
реализует методы `check_local` и `check_global`.

    class Ammo(Supply):

        # --- skiped ---

        def check_local(self):
            for val in super().check_local():
                yield val
            if self.crit < 0:
                yield 'crit', 'Отрицательный шанс крита'
            if self.crit > 25:
                yield 'crit', 'Слишком большой крит'
            if self.power < 0:
                yield 'power', 'Отрицательная мощность'

        def check_global(self, content):
            for val in super().check_global(content):
                yield val
            for weapon in content.weapons.values():
                if weapon.caliber == self.caliber:
                    break
            else:
                yield 'caliber', 'Нет оружия указанного калибра'

`check_local` проверяет саму модель. `check_global` гарантирует, что
модель правильно увязана с остальным контентом. Для этого в
`check_global` передаётся экземпляр менеджера контента.

Проверка запускается консольной утилитой, которая выводит все найденные ошибки.
Нельзя запустить сервер с испорченным контентом.

## Генераторы

Питон замечательно работает с `yaml` файлами, но `JavaScript`
предпочитает `JSON`.  Никаких проблем — контент менеджер может создать
файлы в нужном формате. При этом, как правило, меняется не только
формат записи но структура сохраняемого объекта. Часть полей
записывать не нужно, другие требуют тех или иных
преобразований. Поступаем по аналогии — реализуем в модели метод
`json_view`, который вернет словарь для сериализации.

Ещё одна консольная утилита — и генераторы создали все требуемые файлы.

## Редактор

Написание хорошего и удобного редактора контента — очень большой труд,
по сложности сопоставимый с половиной всей остальной разработки. Лучше
потратить силы на что-то другое. Редактировать нужно `yaml` файлы
вручную. Поэтому мы тщательно следим за тем, что и как
записывается. `yaml` с переусложнённой нечитаемой структурой нужно
менять, добиваясь ясности и простоты.

## Отчёты

И, тем не менее, одних `yaml` файлов мало. Можно увидеть свойства
отдельной пули — но очень неудобно сравнивать пули между собой. Тем
более что немалая часть интересующих параметров является вычисленными
атрибутами.

Для этого у нас есть генераторы отчётов, которые создают `html`
страницы с нужными таблицами и графиками. Написать отчёт гораздо
легче, чем делать редактор (особенно такой редактор, которым самому
было бы приятно пользоваться).

## Карты

У нас простой плоский мир. Карты удобно записывать в стиле
старомодного ascii-art:

    - 'X X X X X X X X X X X X X X X X X X X X X X X X X X X X X '
    - ' X X X X X X X . . . X X X X X X X X X X X X X X X X X X X'
    - 'X X X X X X . . . . . X X X X X X X X X X X X X X X X X X '
    - ' X . . . . . . . . . . . m . . . X X X X X X X X X X X X X'
    - 'X . . . . m . . m . . . . . . O . . X X X X X X X X X X X '
    - ' X . . . . . . . . . b b b . . . . . . X X X X X X X X X X'
    - 'X X . . . O . . . . . , b b . . . . . b . . X X X X X X X '
    - ' X X . . . . . . . . . b . . . . . . b b b b X X X X X X X'
    - 'X . . . . . . . . . . . . . . . . b b b b . . . X X X X X '
    - ' X . . . . . . . . . . . . m . . . b b , . . . . X X X X X'
    - 'X X X . . . . . . . . . . . . . . . . . . . . . m X X X X '
    - ' X X X . m . . . . . . . . . . . . . . . . o . . . X X X X'
    - 'X X X . . . . . . . . . . . . . c . . . . b b b b b . X X '
    - ' X X X . . . . . . . c . . . . . . . . b b b b b b b . X X'
    - 'X X X X . . . . . . . . . c . . . . . . b b b b b b . . X '
    - ' X X X X . . . . . . . . . . . . . . . . . b b b b . . . X'
    - 'X X X X X . . . . . . . . . . . . . . . . . . . . . . . X '
    - ' X X X X X . . . . . . 4 1 . . . . . . . . . . . . . . X X'
    - 'X X X X X X . . . . . . 3 2 . . . . . . . . . . . . . X X '
    - ' X X X X X X X X X . . . . . . . . . . . . . . . . . X X X'
    - 'X X X X X X X X X X . . . . . . . X X X . . . . . . . . X '
    - ' X X X X X X X X X X X . . . . X X X X X . . . X X X X X X'
    - 'X X X X X X X X X X X X X X X X X X X X X X X X X X X X X '

Это кусочек из `yaml` для крошечной карты. X — граница. b —
препятствие. Точка — свободное пространство. 01234m — точки, где могут
появляться игроки и монстры. И так далее. Обратите внимание: карта
имеет шестиугольные клетки. Редактирование довольно тривиально —
главное помнить легенду..

## Итоги

`yaml` + валидатор + набор генераторов на все случаи жизни — очень
простой и мощный комплекс, сильно экономящий время разработки.
